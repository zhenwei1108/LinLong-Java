package com.github.zhenwei.core.math.ec.custom.sec;

import com.github.zhenwei.core.math.ec.AbstractECLookupTable;
import com.github.zhenwei.core.math.ec.ECConstants;
import com.github.zhenwei.core.math.ec.ECCurve;
import com.github.zhenwei.core.math.ec.ECCurve.AbstractF2m;
import com.github.zhenwei.core.math.ec.ECFieldElement;
import com.github.zhenwei.core.math.ec.ECLookupTable;
import com.github.zhenwei.core.math.ec.ECPoint;
import com.github.zhenwei.core.math.raw.Nat192;
import com.github.zhenwei.core.util.encoders.Hex;
import java.math.BigInteger;

public class SecT163R2Curve extends AbstractF2m {

  private static final int SECT163R2_DEFAULT_COORDS = COORD_LAMBDA_PROJECTIVE;
  private static final ECFieldElement[] SECT163R2_AFFINE_ZS = new ECFieldElement[]{
      new SecT163FieldElement(ECConstants.ONE)};

  protected SecT163R2Point infinity;

  public SecT163R2Curve() {
    super(163, 3, 6, 7);

    this.infinity = new SecT163R2Point(this, null, null);

    this.a = fromBigInteger(BigInteger.valueOf(1));
    this.b = fromBigInteger(
        new BigInteger(1, Hex.decodeStrict("020A601907B8C953CA1481EB10512F78744A3205FD")));
    this.order = new BigInteger(1, Hex.decodeStrict("040000000000000000000292FE77E70C12A4234C33"));
    this.cofactor = BigInteger.valueOf(2);

    this.coord = SECT163R2_DEFAULT_COORDS;
  }

  protected ECCurve cloneCurve() {
    return new SecT163R2Curve();
  }

  public boolean supportsCoordinateSystem(int coord) {
    switch (coord) {
      case COORD_LAMBDA_PROJECTIVE:
        return true;
      default:
        return false;
    }
  }

  public int getFieldSize() {
    return 163;
  }

  public ECFieldElement fromBigInteger(BigInteger x) {
    return new SecT163FieldElement(x);
  }

  protected ECPoint createRawPoint(ECFieldElement x, ECFieldElement y) {
    return new SecT163R2Point(this, x, y);
  }

  protected ECPoint createRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs) {
    return new SecT163R2Point(this, x, y, zs);
  }

  public ECPoint getInfinity() {
    return infinity;
  }

  public boolean isKoblitz() {
    return false;
  }

  public int getM() {
    return 163;
  }

  public boolean isTrinomial() {
    return false;
  }

  public int getK1() {
    return 3;
  }

  public int getK2() {
    return 6;
  }

  public int getK3() {
    return 7;
  }

  public ECLookupTable createCacheSafeLookupTable(ECPoint[] points, int off, final int len) {
    final int FE_LONGS = 3;

    final long[] table = new long[len * FE_LONGS * 2];
    {
      int pos = 0;
      for (int i = 0; i < len; ++i) {
        ECPoint p = points[off + i];
        Nat192.copy64(((SecT163FieldElement) p.getRawXCoord()).x, 0, table, pos);
        pos += FE_LONGS;
        Nat192.copy64(((SecT163FieldElement) p.getRawYCoord()).x, 0, table, pos);
        pos += FE_LONGS;
      }
    }

    return new AbstractECLookupTable() {
      public int getSize() {
        return len;
      }

      public ECPoint lookup(int index) {
        long[] x = Nat192.create64(), y = Nat192.create64();
        int pos = 0;

        for (int i = 0; i < len; ++i) {
          long MASK = ((i ^ index) - 1) >> 31;

          for (int j = 0; j < FE_LONGS; ++j) {
            x[j] ^= table[pos + j] & MASK;
            y[j] ^= table[pos + FE_LONGS + j] & MASK;
          }

          pos += (FE_LONGS * 2);
        }

        return createPoint(x, y);
      }

      public ECPoint lookupVar(int index) {
        long[] x = Nat192.create64(), y = Nat192.create64();
        int pos = index * FE_LONGS * 2;

        for (int j = 0; j < FE_LONGS; ++j) {
          x[j] = table[pos + j];
          y[j] = table[pos + FE_LONGS + j];
        }

        return createPoint(x, y);
      }

      private ECPoint createPoint(long[] x, long[] y) {
        return createRawPoint(new SecT163FieldElement(x), new SecT163FieldElement(y),
            SECT163R2_AFFINE_ZS);
      }
    };
  }
}